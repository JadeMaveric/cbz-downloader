#!/bin/bash

### comicarchive Usage:help
#
# When run as standalone, the comicarchive command/subroutine turns a folder of
#
# 	chapter_X/page_*
#
# into a single chapter_X.pdf or chpater_X.cbz
#
# Set NOREMOVE=true to prevent removeal of original files
#
# Set NOERMOVE=false to remove files after archive is made
#
###/doc

#!/bin/bash

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
	local BINEXE=
	for binname in "$@"; do
		# Some implementations of `which` print error messages
		# Not useful here.
		BINEXE=$(which "$binname" 2>/dev/null)

		if [[ -n "$BINEXE" ]]; then
			echo "$BINEXE"
			return 0
		fi
	done
	return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
	[[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
	local binname="$1"; shift

	[[ "$binname" =~ / ]] && { 
		# A relative path cannot be resolved, just check existence
		[[ -e "$binname" ]] && echo "$binname" || return 1

	} || binname="$(which "$binname" 2>/dev/null)"

	# `which` failed
	[[ -n "$binname" ]] || return 1

	[[ -h "$binname" ]] && {

		local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
		bincheck:path "$pointedname" ; return "$?"
	
	} || echo "$binname"
}

#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Colours available:
#
# CDEF -- switches to the terminal default
#
# CRED, CBRED -- red, bold red
# CGRN, CBGRN -- green, bold green
# CYEL, CBYEL -- yellow, bold yellow
# CBLU, CBBLU -- blue, bold blue
# CPUR, CBPUR -- purple, bold purple
#
###/doc

export CRED="\033[0;31m"
export CGRN="\033[0;32m"
export CYEL="\033[0;33m"
export CBLU="\033[0;34m"
export CPUR="\033[0;35m"
export CBRED="\033[1;31m"
export CBGRN="\033[1;32m"
export CBYEL="\033[1;33m"
export CBBLU="\033[1;34m"
export CBPUR="\033[1;35m"
export CDEF="\033[0m"

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'yes' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'yes' to enable command echoing
#
###/doc


MODE_DEBUG=no
MODE_DEBUG_VERBOSE=no

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function out:debug {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift
	fi

	echo -e "${CBRED}ERROR FAIL:$CRED$*$CDEF" 1>&2
	exit $ERCODE
}

function out:dump {
	echo -e -n "${CBPUR}$*" 1>&2
	echo -e -n "$CPUR" 1>&2
	cat - 1>&2
	echo -e -n "$CDEF" 1>&2
}

function out:break {
	[[ "$MODE_DEBUG" = yes ]] || return

	read -p "${CRED}BREAKPOINT: $* >$CDEF " >&2
	if [[ "$REPLY" =~ $(echo 'quit|exit|stop') ]]; then
		out:fail "ABORT"
	fi
}

[[ "$MODE_DEBUG_VERBOSE" = yes ]] && set -x || :
#!/bin/bash

### abspath Usage:bbuild
# Returns the absolute path of a file/directory
#
# Exposes two functions
#
#     abspath:path
#     abspath:simple
#
# Do not use the python-based 'abspath:path' for intensitve resolution;
# instead, use native 'abspath:simple' which is at least 170 times
# more efficient, at the cost of perhaps being potentially
# dumber (simply collapses '/./' and '/../').
# 
# Neither utility expands softlinks.
#
# If python is not found, abspath:path falls back to abspath:simple systematically.
###/doc

function abspath:path {
	local newvar=${1//"'"/"\\'"}
	(
		set +eu
		if which python >/dev/null 2>&1; then
			python  -c "import os ; print os.path.abspath('$newvar')"
		elif which python3 >/dev/null 2>&1 ; then
			python3 -c "import os ; print(os.path.abspath('$newvar') )"
		else
			abspath:simple "$newvar"
		fi
	)
}

# More efficient by a factor of at least 170:1
# compared to spinning up a python process every time
function abspath:simple {
	local workpath="$1"
	if [[ "${workpath:0:1}" != "/" ]]; then workpath="$PWD/$workpath"; fi
	for x in {1..50}; do # set a limit on how many iterations - only very stupid paths will get us here.
		if [[ "$workpath" =~ '/../' ]] || [[ "$workpath" =~ '/./' ]]; then
			workpath="$(echo "$workpath"|sed -r -e 's#/./#/#g' -e 's#([^/]+)/../#\1/#g' -e 's#/.$##' -e 's#([^/]+)/..$#\1#' )"
		else
			echo "$workpath"
			return 0
		fi
	done
	return 1 # hopefully we never get here
}

make_archive:remove() {
	local targetdir="$1"; shift
	[[ "${NOREMOVE:-}" = true ]] || { cd ..; rm -r "$targetdir" ; }
}

make_archive:pdf() {
	local targetdir="$(abspath:simple "$1")"; shift
	local archivename="$targetdir.pdf"

	if bincheck:has img2pdf; then
		(
		cd "$targetdir/"
		img2pdf -o "$archivename" page_* && {
			cd ..
			make_archive:remove "$targetdir"
		}
		)
	else
		out:warn "'img2pdf' command not installed"
	fi
}

make_archive:cbz() {
	local targetdir="$(abspath:simple "$1")"; shift
	local archivename="$targetdir.cbz"

	if bincheck:has zip; then
		(
		# Comic book archives need a special comic book reader
		#  but they are recognized by eBook readers, and can be unpacked
		#  since they're literally a ZIP file
		#  and displayed in name order
		cd "$targetdir/"
		zip "$archivename" page_* && {
			cd ..
			make_archive:remove "$targetdir"
		}
		)
	else
		out:warn "'zip' command not installed"
	fi
}

make_archive:main() {
	local archivetype="$1"; shift
	local targetdir="$1"; shift

	case "$archivetype" in
	pdf)
		make_archive:pdf "$targetdir"
		;;
	cbz)
		make_archive:cbz "$targetdir"
		;;
	*)
		out:fail "Wrong archive type name [$archivetype] - choose 'cbz' or 'pdf'"
		;;
	esac
}

if [[ -z "${NOREMOVE:-}" ]]; then
	NOREMOVE=false
fi

runmain comicarchive make_archive:main "$@"
