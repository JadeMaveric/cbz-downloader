#!/bin/bash

### mfcom Usage:help
#
# MangaFox Compiler
#
# Get all pages from a MangaFox commic to a local directory
#
# USAGE
#
# 	mfcom URL [ START [[+]END] ]
#
# Specify the URL of the main manga page
#
# Optionally specify the start chapter
#
# Optionally specify the end chapter, or a "+" followed by the number of chapters to download
#
# CONFIGURATION
#
# Set the following environment variables to configure mfcom:
#
# MFCOM_UAGENT="<user agent string>"
# 	set a custom user agent string instead of the default (Mozilla 52)
#
# MFCOM_MAKE_ARCHIVE={pdf | cbz}
# 	tries to compile to PDF or CBZ comic archive
#
# 	PDF requires img2pdf (apt install img2pdf)
# 	CBZ requires zip     (apt install zip)
#
# MFCOM_WAIT=<int>
# 	time in seconds to wait between operations ; default is 1
# 	mangafox seems to throttle access from IPs that download too much too fast
# 	set to 0 for no delay
#
###/doc

set -euo pipefail

SURLFILE="source.url"
LASTINDEXFILE="last-tried.txt"

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
	local required_name="$1"; shift
	local funcall="$1"; shift
	local scriptname="$(basename "$0")"

	if [[ "$required_name" = "$scriptname" ]]; then
		"$funcall" "$@"
	fi
}
#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
###/doc

export CRED="\033[0;31m"
export CGRN="\033[0;32m"
export CYEL="\033[0;33m"
export CBLU="\033[0;34m"
export CPUR="\033[0;35m"
export CTEA="\033[0;36m"

export CBRED="\033[1;31m"
export CBGRN="\033[1;32m"
export CBYEL="\033[1;33m"
export CBBLU="\033[1;34m"
export CBPUR="\033[1;35m"
export CBTEA="\033[1;36m"

export HLRED="\033[41m"
export HLGRN="\033[42m"
export HLYEL="\033[43m"
export HLBLU="\033[44m"
export HLPUR="\033[45m"
export HLTEA="\033[46m"

export CDEF="\033[0m"

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
	OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
	if [[ "$MODE_DEBUG" = true ]]; then
		echo -e "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
	fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
	echo -e "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
	OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
	[[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

	[[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return

	for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
		"$@" "$buffer_line"
	done

	out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift
	fi

	echo -e "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
	exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
	echo -e "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
	echo -e -n "${CBPUR}$*" 1>&2
	echo -e -n "$CPUR" 1>&2
	cat - 1>&2
	echo -e -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
	[[ "$MODE_DEBUG" = true ]] || return

	read -p "${CRED}BREAKPOINT: $* >$CDEF " >&2
	if [[ "$REPLY" =~ quit|exit|stop ]]; then
		out:fail "ABORT"
	fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
	set -x
fi
#!/bin/bash

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
	local SECTION_STRING="${1:-}"; shift
	local TARGETFILE="${1:-}"; shift
	[[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
	[[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
				echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
	echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
	: ${PAGER=less}
	autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#	#!/bin/bash
#
#	### Some help Usage:help
#	#
#	# Some help text
#	#
#	###/doc
#
#	#%include autohelp.sh
#
#	main() {
#		autohelp:check "$@"
#
#		# now add your code
#	}
#
#	main "$@"
#
###/doc
autohelp:check() {
	if [[ "$*" =~ --help ]]; then
		cols="$(tput cols)"
		autohelp:print | fold -w "$cols" -s || autohelp:print
		exit 0
	fi
}
#!/bin/bash

### Varify Usage:bbuild
# Make a string into a valid variable name or file name
#
# Collapses any string of invalid characters into a single underscore
#
# For example
#
# 	varify:var "http://example.com"
#
# returns
#
# 	http_example.com
#
###/doc

### varify:var Usage:bbuild
#
# Valid characters for varify:var are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
###/doc
function varify:var {
	echo "$*" | sed -r 's/[^a-zA-Z0-9_]/_/g'
}

### varify:fil Usage:bbuild
#
# Valid characters for varify:fil are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
# * dash ("-")
# * period (".")
#
# Can be used to produce filenames.
#
###/doc
function varify:fil {
	echo "$*" | sed -r 's/[^a-zA-Z0-9_.-]/_/g'
}
#!/bin/bash

### comicarchive Usage:help
#
#	comicarchive { cbz | pdf } COMICFOLDER
#	make_archive:main { cbz | pdf } COMICFOLDER
#
# When run as standalone, the comicarchive command/subroutine turns a folder of
#
# 	chapter_X/page_*
#
# into a single chapter_X.pdf or chapter_X.cbz
#
# Set NOREMOVE=true to prevent removeal of original files
#
# Set NOERMOVE=false to remove files after archive is made
#
###/doc

#!/bin/bash

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
	local BINEXE=
	for binname in "$@"; do
		# Some implementations of `which` print error messages
		# Not useful here.
		BINEXE=$(which "$binname" 2>/dev/null)

		if [[ -n "$BINEXE" ]]; then
			echo "$BINEXE"
			return 0
		fi
	done
	return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
	[[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
	local binname="$1"; shift

	[[ "$binname" =~ / ]] && { 
		# A relative path cannot be resolved, just check existence
		[[ -e "$binname" ]] && echo "$binname" || return 1

	} || binname="$(which "$binname" 2>/dev/null)"

	# `which` failed
	[[ -n "$binname" ]] || return 1

	[[ -h "$binname" ]] && {

		local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
		bincheck:path "$pointedname" ; return "$?"
	
	} || echo "$binname"
}

#!/bin/bash

### abspath:path RELATIVEPATH Usage:bbuild
# Returns the absolute path of a file/directory
###/doc

function abspath:path {
	local workpath="$1"
	if [[ "${workpath:0:1}" != "/" ]]; then workpath="$PWD/$workpath"; fi

	workpath="$(abspath:strip_dot "$workpath")"
	abspath:resolve_dotdot "$workpath" | sed -r 's|/$||'
}

function abspath:strip_dot {
	echo "$1" | sed -r 's@/\./@/@g;s@/.$@@'
}

function abspath:resolve_dotdot {
	local workpath="$1"; shift

	# Set a limit on how many iterations to perform
	# Only very obnoxious paths should fail
	for x in {1..50}; do
		#out:info "Iteration $x : $workpath"

		# No more dot-dots - good to go
		if [[ ! "$workpath" =~ /\.\.(/|$) ]]; then
			echo "$workpath"
			return 0
		fi

		# Starts with an up-one at root - unresolvable
		if [[ "$workpath" =~ ^/\.\.(/|$) ]]; then
			return 1
		fi

		workpath="$(echo "$workpath"|sed -r 's@[^/]+/\.\.(/|$)@@;s@/$@@')"
	done

	# A very obnoxious path was used.
	return 1
}

make_archive:remove() {
	local targetdir="$1"; shift
	[[ "${NOREMOVE:-}" = true ]] || { cd ..; rm -r "$targetdir" ; }
}

make_archive:pdf() {
	local targetdir="$(abspath:path "$1")"; shift
	local archivename="$targetdir.pdf"

	if bincheck:has img2pdf; then
		(
		cd "$targetdir/"
		img2pdf -o "$archivename" page_* && {
			cd ..
			make_archive:remove "$targetdir"
		}
		)
	else
		out:warn "'img2pdf' command not installed"
	fi
}

make_archive:cbz() {
	local targetdir="$(abspath:path "$1")"; shift
	local archivename="$targetdir.cbz"

	if bincheck:has zip; then
		(
		# Comic book archives need a special comic book reader
		#  but they are recognized by eBook readers, and can be unpacked
		#  since they're literally a ZIP file
		#  and displayed in name order
		cd "$targetdir/"
		zip "$archivename" $(echo page_*) && {
			cd ..
			make_archive:remove "$targetdir"
		}
		)
	else
		out:warn "'zip' command not installed"
	fi
}

make_archive:main() {
	local archivetype="$1"; shift
	local targetdir="$1"; shift

	case "$archivetype" in
	pdf)
		make_archive:pdf "$targetdir"
		;;
	cbz)
		make_archive:cbz "$targetdir"
		;;
	*)
		out:fail "Wrong archive type name [$archivetype] - choose 'cbz' or 'pdf'"
		;;
	esac
}

if [[ -z "${NOREMOVE:-}" ]]; then
	NOREMOVE=false
fi

runmain comicarchive make_archive:main "$@"

# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#	MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
	local PATHS="$1"; shift
	local FILE="$1"; shift

	out:debug "Looking for file [$FILE] amongst [$PATHS]"

	for path in $(echo "$PATHS"|tr ':' ' '); do
		out:debug "Try path: $path"
		local fpath="$path/$FILE"
		if [[ -f "$fpath" ]]; then
			echo "$fpath"
			return
		else
			out:debug "No $fpath"
		fi
	done
	return 1
}

wgetdl() {
	local downloadfile="$1"; shift
	if [[ -z "$*" ]]; then
		out:warn "Error downloading $downloadfile"
		return 404
	fi

	wget --header="User-Agent: $MFCOM_UAGENT" --header="Accept: text/html, image/*" --quiet -O "$downloadfile" --no-check-certificate "$@" || :
	do_unzip "$downloadfile"
}

get_mainList() {
	wgetdl "$F_MAIN" "$U_MAINPAGE"
}

extract_links() {
	local sourcefile="$1"; shift
	local targetfile="$1"; shift

	grep "$U_MAINPAGE_NOSCHEME" "$sourcefile" | \
		grep -Po 'a href="'"$U_MAINPAGE_NOSCHEME"'.*?"' | \
		grep -Po "$U_MAINPAGE_NOSCHEME[^\"]+" | \
		sed -r 's|^|http:|' | tac \
		> "$targetfile"
}

unzero() {
        local unzeroed="$(echo "$1"|sed -r s/^0+//)"
        if [[ -z "$unzeroed" ]]; then
                echo "0"
        else
                echo "$unzeroed"
        fi
}

is_bigger_or_eq() {
	[[ ! $(dc -e "$1 $2 - p") =~ - ]] || return 1
}

is_smaller() {
	! is_bigger_or_eq "$1" "$2"
}

do_unzip() {
	if (file "$1"|grep gzip -q); then
		mv "$1" "$1.gz"
		gunzip "$1.gz"
	fi
}

set_image_extension() {
	local imagefile="$1"; shift
	local typestring="$(file "$imagefile")"
	local imagetype="$(echo "$typestring"|egrep -oi 'jpeg|jpg|png|gif' | tr '[:upper:]' '[:lower:]')"
	local extension=bin

	out:debug "Renaming $imagefile"

	case "$imagetype" in
		jpeg|jpg)
			extension=jpg ;;
		png|gif)
			extension="$imagetype" ;;
		*)
			out:warn "Could not determine extension for [$imagefile] : $typestring)"
			out:debug "    (using $noimgf instead)"
			rm "$imagefile" 2>/dev/null || :
			cp "$noimgf" "${imagefile}.png"
			return ;;
	esac

	mv "$imagefile" "$imagefile.$extension"

	lastextension="$extension"
}

download_chapter_page() {
	local pageurl="$1"; shift
	local targetfile="$1"; shift

	out:info "Download [$pageurl] to [$targetfile]"

	wgetdl "$targetfile" "$pageurl"
	[[ "$?" = 404 ]] && out:fail 404 "Page not found"

	local imgurl="$(grep '<img' "$targetfile"|grep 'id="image"'|grep -oP 'src="[^"]+')"

	out:debug "Cutting $imgurl"

	imgurl="${imgurl:5}"

	out:debug "$imgurl : $targetfile"
	wgetdl "$targetfile" "$imgurl"
	[[ "$?" = 404 ]] && out:fail 404 "Image not found"
	set_image_extension "$targetfile"
}

padnum() {
	printf "%03d" "$1"
}

download_chapter() {
	local chapter_url="$1"; shift
	local base_url="$(dirname "$chapter_url")"
	local targetdir="$1"; shift
	local chapnum="$1"; shift

	targetdir="$targetdir/${D_TARGET}-${chapnum}"

	local dlfile="$targetdir/fpage.html"
	local chapdir="$(basename "$targetdir")"

	mkdir -p "$targetdir"

	# Register the last attempt now, in case fail before end
	echo "$chapnum" > "$F_LASTDONE"

	wgetdl "$dlfile" "$chapter_url"

	local pagecount="$(grep -oP 'of\s*\d+' "$dlfile"|sort|uniq|cut -d' ' -f2)"

	local i=0
	while [[ "$i" -lt "$pagecount" ]]; do
		i=$((i+1))
		download_chapter_page "$base_url/$i.html" "$targetdir/page_$(padnum "$i")"
		sleep "$MFCOM_WAIT"
	done

	[[ "$i" -gt 0 ]] || {
		out:warn "Nothing downloaded !"
		rm -r "$targetdir"
		return
	}

	local archivename="$(varify:fil "$chapdir")"
	if [[ "${MFCOM_MAKE_ARCHIVE:-}" = pdf ]]; then
		make_archive:pdf "$targetdir"
	elif [[ "${MFCOM_MAKE_ARCHIVE:-}" = cbz ]]; then
		make_archive:cbz "$targetdir"
	fi
}

download_all_chapters() {
	local chapnum=0
	while read LINKLINE; do
		chappat="/c([0-9.]+)/?"
		[[ "$LINKLINE" =~ $chappat ]]
		chapnum="${BASH_REMATCH[1]}"
		if [[ -z "$chapnum" ]]; then
			out:warn "Could not extract chapter number from $LINKLINE"
			continue
		fi

		if [[ -n  "$STARTINDEX" ]]; then
			# chapter number < desired start index
			if is_smaller "$chapnum" "$STARTINDEX"; then continue; fi

			if [[ -n "$ENDINDEX" ]]; then
				# chapter number >= desired end index
				if is_bigger_or_eq "$chapnum" "$ENDINDEX" ; then break; fi
			fi
		fi
		
		download_chapter "$LINKLINE" "$D_TARGET" "${chapnum}"

	done < "$F_LINKS"
}

numcheck() {
	local tocheck="$1"; shift

	if [[ ! "$tocheck" =~ ^[0-9]*$ ]]; then
		out:fail "Invalid number: $*"
	fi
}

get_main_url() {
	U_MAINPAGE="$1"; shift

	if [[ -d "$U_MAINPAGE" ]] && [[ -f "$U_MAINPAGE/$SURLFILE" ]]; then
		U_MAINPAGE="$(cat "$U_MAINPAGE/$SURLFILE")"

	elif [[ ! "$U_MAINPAGE" =~ ^https?:// ]]; then
		out:fail "Invalid page URL $U_MAINPAGE"
	fi
}

set_indices() {
	STARTINDEX="${1:-}"
	ENDINDEX="${2:-}"

	[[ -n "$STARTINDEX" ]] || return 0

	numcheck "$STARTINDEX" start index

	[[ -n "$ENDINDEX" ]] || return 0

	if [[ "$ENDINDEX" =~ ^\+ ]]; then
		ENDINDEX="${ENDINDEX#+}"
		numcheck "$ENDINDEX" end index length
		ENDINDEX=$((STARTINDEX + ENDINDEX))
	else
		numcheck "$ENDINDEX" end index
		is_smaller "$STARTINDEX" "$ENDINDEX" || out:fail "Start index must be smaller than end index"
	fi
}

setup_configuration() {
	# Mangafox has started generating urls without schemes
	U_MAINPAGE_NOSCHEME="$(echo "$U_MAINPAGE"|sed -r 's|https?://|//|')"

	set_indices "${1:-}" "${2:-}"

	D_TARGET="$(varify:fil "${U_MAINPAGE##*/manga/}")"
	D_TARGET="${D_TARGET%_}"
	F_MAIN="$D_TARGET/frontpage.html"
	F_LINKS="$D_TARGET/links.txt"
	F_SOURCEURL="$D_TARGET/$SURLFILE"
	F_LASTDONE="$D_TARGET/$LASTINDEXFILE"

	mkdir -p "$D_TARGET"

	[[ -f "$F_SOURCEURL" ]] || echo "$U_MAINPAGE" > "$F_SOURCEURL"
	[[ -z "$STARTINDEX" ]] && [[ -f "$F_LASTDONE" ]] && STARTINDEX="$(cat "$F_LASTDONE")" || :
}

announce_setup() {
	echo "MFCOM_WAIT=$MFCOM_WAIT"
	echo "MFCOM_MAKE_ARCHIVE=${MFCOM_MAKE_ARCHIVE:-}"
	echo "Downloading from: $U_MAINPAGE"
	echo "Downloading to:   $D_TARGET"
	echo "Starting at: $STARTINDEX"
	echo "Ending at:   $ENDINDEX"
	sleep 2
}

get_noimg() {
	local nilplaces
	nilplaces="$HOME/.local/lib/mfcom:/usr/local/lib/mfcom"
	noimgf="$(searchpaths:file_from "$nilplaces" none.png)"

	[[ -n "$noimgf" ]] || out:fail "Could not find nil image none.png amongst [$nilplaces]"
}

main() {
	if [[ -z "$*" ]]; then
		autohelp:print
		exit
	fi

	: ${MFCOM_UAGENT="Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"}

	: ${MFCOM_WAIT=2}

	get_noimg

	get_main_url "$1"; shift
	setup_configuration "${1:-}" "${2:-}"
	shift 2 || :

	announce_setup

	get_mainList
	extract_links "$F_MAIN" "$F_LINKS"
	download_all_chapters
}

runmain mfcom main "$@"

