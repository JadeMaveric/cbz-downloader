#!/bin/bash

### TGZ to ZIP converter Uasge:help
#
# Convert a .tgz/.tar.gz file to a ZIP file
#
# By default, will not remove the tgz file ; set remove_after=true environment variable to remove the tgz on success
#
# By default, tries to detect and ".tar.gz" in the original filename; override this using the env variable ext_tgz
#
# By default, appends ".zip" to the destination filename; override this using the env variable ext_zip
#
#
# Example: converting tgz-based CBZ files to ZIP-based CBZ files:
#
# 	export ext_tgz=.cbz
# 	export ext_zip=.cbz
# 	export remove_after=true
# 	tgz-zip *.cbz
#
# Or, in one line:
#
# 	ext_tgz=.cbz ext_zip=.cbz remove_after=true tgz-zip *.cbz
#
###/doc

#!/bin/bash

### autohelp:print Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
###/doc

HELPCHAR='#'

function autohelp:print {
	local USAGESTRING="${1:-}"; shift
	local TARGETFILE="${1:-}"; shift
	[[ -n "$USAGESTRING" ]] || USAGESTRING=help
	[[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$USAGESTRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
				echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
	echo ""
}

### automatic help Usage:main
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$*" =~ --help ]]; then
	cols="$(tput cols)"
	autohelp:print | fold -w "$cols" -s || autohelp:print
	exit 0
fi
### main:script SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the main:script call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
	local required_name="$1"; shift
	local funcall="$1"; shift
	local scriptname="$(basename "$0")"

	if [[ "$required_name" = "$scriptname" ]]; then
		"$funcall" "$@"
	fi
}

set -euo pipefail

#!/bin/bash

### abspath Usage:bbuild
# Returns the absolute path of a file/directory
#
# Exposes two functions
#
#     abspath:path
#     abspath:simple
#
# Do not use the python-based 'abspath:path' for intensitve resolution;
# instead, use native 'abspath:simple' which is at least 170 times
# more efficient, at the cost of perhaps being potentially
# dumber (simply collapses '/./' and '/../').
# 
# Neither utility expands softlinks.
#
# If python is not found, abspath:path falls back to abspath:simple systematically.
###/doc

function abspath:path {
	local newvar=${1//"'"/"\\'"}
	(
		set +eu
		if which python >/dev/null 2>&1; then
			python  -c "import os ; print os.path.abspath('$newvar')"
		elif which python3 >/dev/null 2>&1 ; then
			python3 -c "import os ; print(os.path.abspath('$newvar') )"
		else
			abspath:simple "$newvar"
		fi
	)
}

# More efficient by a factor of at least 170:1
# compared to spinning up a python process every time
function abspath:simple {
	local workpath="$1"
	if [[ "${workpath:0:1}" != "/" ]]; then workpath="$PWD/$workpath"; fi
	for x in {1..50}; do # set a limit on how many iterations - only very stupid paths will get us here.
		if [[ "$workpath" =~ '/../' ]] || [[ "$workpath" =~ '/./' ]]; then
			workpath="$(echo "$workpath"|sed -r -e 's#/./#/#g' -e 's#([^/]+)/../#\1/#g' -e 's#/.$##' -e 's#([^/]+)/..$#\1#' )"
		else
			echo "$workpath"
			return 0
		fi
	done
	return 1 # hopefully we never get here
}

: ${ext_tgz=.tar.gz}
: ${ext_zip=.zip}

makezip() {
	local zipname="$1"; shift
	if [[ -e "$zipname" ]]; then
		zipname="${zipname}-2"
	fi

	# Initialize to avoid undefined variable
	local filearray=("$zipname")

	for x in * .*; do
		if [[ "$x" = . ]] || [[ "$x" = .. ]]; then continue; fi

		filearray=("${filearray[@]}" "$x")
	done

	zip -r "${filearray[@]}"
}

core_name() {
	local filename="$1"; shift

	filename="${filename%$ext_tgz}"

	echo "$filename"
}

tgzzip:main() {
	for item in "$@"; do
		local core_name="$(core_name "$item")"
		local filepath="$(abspath "$item")"
		local targetdir="$PWD"

		local opdir="$(mktemp -d)"

		# Unpack in temp, repack to destination
		pushd "$opdir"
		tar xzf "$filepath" && makezip "$targetdir/${core_name}$ext_zip" || { popd; continue; }

		# Cleanup
		popd
		rm -rf "$opdir"
		if [[ "${remove_after:-}" = true ]]; then
			rm "$filepath"
		fi

	done
}

runmain tgz-zip tgzzip:main "$@"
